'''
Foundations of Programming: Object-Oriented Design
'''
Intro.6
"To write any piece of software, we need to do three things:
    1. Understand our problem - Analysis
    2. Plan our solution - Design
    3. Build it - Programming
    "


1.2
    Objects in programming are similar to objects in real-life. They have:
        1. Identity (are separate from things like them)
        2. Attributes (characteristics about them, like names or colors)
        3. Behavior (they do something or receive some action)

1.3
    Classes have names, attributes, and methods (functions).

1.4 through 1.7
    APIE =
        Abstraction: Focus on the essential qualities of an example, leaving out extras
        Polymorphism: an object's ability to behave differently in different
            instances / situations.
        Inheritance: A subclass inherits all the attributes and behaviors of the
            superclass.
        Encapsulation = bundling attributes of a class together and hiding them
            from other parts of the application. This is less for secrecy and
            more for avoiding cascading problems when changing things.

2.1
    Steps in the OO Analysis and Design Process:
        1. Gather requirements
            a) What does the app need to do?
        2. Describe the app
            a) Simple narrative of how people use the app to complete its goal.
        3. Identify the main objects
            a) Go back through the narrative, find the most important objects
                actions, and results, and discard superfluous things
        4. Describe the Interactions
            a) Figure out how your objects interact with each other
        5. Create a Class Diagram

2.2
    Requirements - What must the program do?
    NOTE: Cut the fluff here. No half-formed ideas on what might be cool.
          Only things that it MUST have/do.
        Functional Requirements
            Features and Capabilities
        Non-Functional Requirements
            Help
            Legal
            Performance
            Support
            Security

        FURPS / FURPS+
            Functional requirements
            Usability requirements
            Reliability requirements
            Performance requirements
            Supportability requirements

            +
            Design requirements
            Implementation requirements
            Interface requirements
            Physical requirements

3.1
    Use Cases - used to explain how and why a user will use the application
        Should be simple and in plain English
    Use cases have three parts:
        1) Title - short phrase, active verb
        2) Actor - person accomplishing goal
        3) Scenario - step-by-step on how the actor accomplishes goal
            Paragraph of short, declarative sentences
            Numbered list of steps
        3.5) Extensions - covers situations not seen in normal scenario
                Issues, Exceptions, etc.

3.2
    Actors are people (or systems) that live outside the application that
    need to accomplish goals within the application.
    -Determine if you need different roles or security clearance between different Actors
    -The same person could be different actors on different days, as the
        actor designation revolves around what they want to accomplish

3.3
    Identifying the scenarios
        Create user-focused goals (not "login to account", but rather
        what the user wants to do when they login.)
            -emphasize the goal of one encounter
        Sunny Day Use Case - describes what happens when everything goes correctly
        Include other common scenarios and how they are handled
        omit needless words. keep it simple
        
